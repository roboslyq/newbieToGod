#问题1：Java中的同步集合与并发集合有什么区别
##解析：

>　　同步集合：
>
>>　　　　- Hashtable
>
>>　　　　- Vector
>
>>　　　　- 同步集合包装类：Collections下面的方法可以获取线程安装的同步集合：
>
>>>　　　　　　synchronizedCollection(Collection<T> c)
>
>>>　　　　　　synchronizedList(List<T> list)
>
>>>　　　　　　synchronizedMap(Map<k, v> m)
>
>>>　　　　　　synchronizedSet(Set<T> set)
>
>>>　　　　　　synchronizedSortedMap(SortedMap<k ,v> sm)
>
>　　　　同步集合的优缺点：在单线程环境下可以保证数据安全，但是是通过synchronized关键字实现同步方法将访问操作串行化，导致在并发环境中效率降低。且在多线程环境下的复合操作是非线程安全的，需要加锁来实现。
>并发集合：

>　　　　Java提供了两类的并发集合：
>
>>　　　　　　- 阻塞式集合(blocked collection)：这类集合包含添加和移除的方法，当集合已满或者为空时被调用的添加或者移除方法就不能立刻执行，那么调用这个方法的线程将会被阻塞，一直到改方法被调用成功。
>
>>　　　　　　- 非阻塞式集合(Non-blocked collection): 这类集合包含添加和移除方法，如果集合已满或者为空时，调用添加或移除方法会返回null或者报错，但是调用这个方法的线程不会被阻塞。
>
>>　　　　常见的并发集合包括：
>
>>>　　　　　　- 非阻塞列表对应的实现类：ConcurrentLinkedDeque
>
>>>　　　　　　- 阻塞式列表对于的实现类：LinkedBlockingDeque
>
>>>　　　　　　- 用于数据生成或者消费的阻塞式列表对应的实现类：LinkedTransferQueue
>
>>>　　　　　　- 按照优先级排序列表元素的阻塞式列表对应的实现类：PriorityBlockingQueue
>
>>>　　　　　　- 带有延迟列表元素的阻塞式列表对应的实现类：DelayQueue
>
>>>　　　　　　- 非阻塞式列表可遍历映射对应的实现类ConcurrentSkipListMap
>
>>>　　　　　　- 随机数字对应的实现类：ThreadLockRandom
>
>>>　　　　　　- 原子变量对应的实现类：AtomicLong和AtomicIntegerArray

#问题2：java中invokeAndWait和invokeLater有什么区别？
##解析:
　　事件派发线程是swing的组件，swing是事件驱动的，所有的操作都需要事件派发线程去完成，但是有些很费事的操作不太好放到事件派发线程中去。

　　SwingUtils提供了两个方法：invokeAndWait和invokeLater，他们都是事件派发线程可运行的对象，当对象位于事件派发队列的队首时，他们就被执行其中的run()，方法是允许事件派发线程调用另一个线程中的任意一个方法。

　　invokeAndWait和invokeLater都可将可运行对象放到事件派发队列中去，但是invokeLater将对象放入队列就返回了，invokeAndWait将对象放入后直到已启动了可运行的run()时才返回。

#问题3：什么是FutureTask
##解析：
　　Runnable是一个接口，封装了一个没有参数和返回值异步执行的方法。

　　Future也是一个接口，且其中保存异步计算的结果：
　　FutureTask则同时实现了上述两个接口
FutureTask内部提供了定义了以下变量：

　　volatile int state:表示对象状态，volatile关键字保证了内存可见性。futureTask中定义了7种状态，代表了7种不同的执行状态
　　Callable callable:被提交的任务

　　Object outcome:任务执行结果或者任务异常

　　volatile Thread runner:执行任务的线程

　　volatile WaitNode waiters：等待节点，关联等待线程

　　long stateOffset:state字段的内存偏移量

　　long runnerOffset：runner字段的内存偏移量

　　long waitersOffset：waiters字段的内存偏移量 
　　注：后三个字段是配合Unsafe类做CAS操作使用的。

	任务流程：创建一个futureTask对象task
提交task到调度器executor等待调度或者在另外一个线程中执行task

等待调度中...

如果此时currentThread调取执行结果task.get(),会有几种情况
if task 还没有被executor调度或正在执行中
    阻塞当前线程，并加入到一个阻塞链表中waitNode
else if task被其它Thread取消，并取消成功 或task处于中断状态
    throw exception
else if task执行完毕，返回执行结果，或执行存在异常，返回异常信息
    
        
如果此时有另外一个线程调用task.get()
    
执行过程同上
总结下，FutureTask的状态流转过程，可以出现以下四种情况： 
1. 任务正常执行并返回。 NEW -> COMPLETING -> NORMAL 
2. 执行中出现异常。NEW -> COMPLETING -> EXCEPTIONAL 
3. 任务执行过程中被取消，并且不响应中断。NEW -> CANCELLED 
4.任务执行过程中被取消，并且响应中断。 NEW -> INTERRUPTING -> INTERRUPTED