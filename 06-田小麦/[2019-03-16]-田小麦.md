##### 20190316
* <font color=#FF0000>Java中的同步集合与并发集合有什么区别？</font> 
```
并发集合： 
ConcurrentHashMap 
CopyOnWriteArrayList 
CopyOnWriteArraySet
同步集合： 
HashTable 
Vector 
同步集合器Collections.synchronizedList(list)、Collections.synchronizedSet(set)、Collections.synchronizedMap(map)
二者都支持线程安全，区别主要体现在实现线程安全的方式，因此在性能和可扩展性上有明显不同！！！ 
同步集合是把整个集合锁起来，所以性能较差； 
并发集合是通过锁剥离、COW等技术使得多个线程可以同时访问集合，所以性能很好。
```
* <font color=#FF0000>Java中invokeAndWait和invokeLater有什么区别？</font> 
```
1、invokeLater和invokeAndWait都是将run方法中的代码交给同一个线程（即EDT，事件分发线程）去处理，按照顺序排队执行。
2、invokeLater方法，将run方法交给EDT后，接着直接返回（不关注是否执行了），main方法继续执行。
3、invokeAndWait方法，将run方法交给EDT后，会等待run方法执行完，main方法才继续向下执行。
4、关于事件队列与事件分发线程：
为按钮设置监听器——点击按钮——产生按钮点击事件——该事件会进入事件队列（Event Queue）等待执行——事件分发线程（EDT）从事件队列中一个一个的顺序取出——然后执行相应的事件处理方法（监听器中的方法）
```
* <font color=#FF0000>什么是FutureTask？</font>
``` 
1、FutureTask实现了RunnableFuture接口，而RunnableFuture继承了Runnable和Future，也就是说FutureTask既是Runnable，也是Future。
2、有两个构造方法，其中传Runnable的最后通过适配器的方式装换成了Callable，这样的话，FutureTask一定就会持有Callable对象的应用，当线程调用到run()方法时，里面调用到Callable的call() 方法就可以了。执行流程可以看成是这样的Runnable（run()）--->Callable（call()）。由于FutureTask实现了Future接口，这样就可以达到对run()方法实现一个监视的功能，其实就是对线程的一个监视了。线程的执行状态是通过state来保存的。
3、FutureTask执行多任务计算的使用场景
利用FutureTask和ExecutorService，可以用多线程的方式提交计算任务，主线程继续执行其他任务，当主线程需要子线程的计算结果时，在异步获取子线程的执行结果.
```