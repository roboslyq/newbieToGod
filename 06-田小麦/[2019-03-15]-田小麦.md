#####  20190315
* <font color=#FF0000>线程池作用，主要实现类，并说出实现类场景以及区别？</font>
```
线程池作用：线程创建销毁开销大，用空间换时间。
主要实现类：ThreadPoolExecutor\ScheduledThreadPoolExecutor。
场景：ThreadPoolExecutor
1、FixedThreadPool
　　这是一个线程数固定的线程池，当这个线程池被创建的时候，池里的线程数就已经固定了。当需要运行的线程数量大体上变化不大时，适合使用这种线程池。固定数量还有一个好处，它可以一次性支付高昂的创建线程的开销，之后再使用的时候就不再需要这种开销。
2、SingleThreadExecutor
	这是一个线程数量为1的线程池，所有提交的这个线程池的任务都会按照提交的先后顺序排队执行。单个线程执行有个好处：由于任务之间没有并发执行，因此提交到线程池种的任务之间不会相互干扰。程序执行的结果更具有确定性。
3、CachedThreadPool
	一看到Cache就知道这是一个和缓存有关的线程池，每次有任务提交到线程池的时候，如果池中没有空闲的线程，线程池就会为这个任务创建一个线程，如果有空闲的线程，就会使用已有的空闲线程执行任务。有的人可能会有个疑惑：这样线程不就越来越多了吗？其实不是的，这个线程池还有一个销毁机制，如果一个线程60秒之内没有被使用过，这个线程就会被销毁，这样就节省了很多资源。CachedThreadPool是一个比较通用的线程池，它在多数情况下都能表现出优良的性能。以后编码的时候，遇事不决，用缓存（线程池）。
技巧：我们可以使用Executors方便创建各种类型的ThreadPoolExecutor
```
* <font color=#FF0000>ThreadPoolExecutor使用场景。以及原理 ?</font> 
```
也就是线程池的实现原理：
当向线程池提交一个任务之后，线程池的处理流程如下：
1.线程池中是否有工作线程可以处理这个任务。如果没有工作线程，新建工作线程并处理这个任务。
2.线程池中有空闲工作线程，则直接提交给这个工作线程执行任务。
3.线程池中没有可用线程并且不能新建线程，则将任务放入任务队列(workqueue)，如果此时工作队列已满，则采用拒收策略，进行任务补救措施。
```
* <font color=#FF0000>Executor拒绝策略说的是什么？</font> 
```
jdk默认提供四种拒收策略
丢弃策略是系统超负荷运行的最后补救措施，线程池满了，并且阻塞队列满了，丢弃策略有如下四种：
（1）ThreadPoolExecutor.AbortPolicy：抛出RejectedExecutionException异常，丢弃任务，阻止系统正常工作。 【Executors类创建线程池的默认丢弃策略】
（2）ThreadPoolExecutor.DiscardPolicy：偷偷的丢弃任务，但是不抛出异常。 
（3）ThreadPoolExecutor.DiscardOldestPolicy：丢弃最老的任务（即队首马上要执行的任务），然后重新尝试执行任务（重复此过程）
（4）ThreadPoolExecutor.CallerRunsPolicy：只要线程池未关闭，直接去调用线程池的线程中处理该任务，可能引起性能的急剧下降。
From:https://blog.csdn.net/qq_26012495/article/details/84325445
```
* <font color=#FF0000>无界阻塞延迟队列delayqueue原理是什么？</font> 
```
DelayQueue中内部使用的是PriorityQueue存放数据，使用ReentrantLock实现线程同步，是阻塞队列。队列里面的元素要实现Delayed接口，一个是获取当前剩余时间的接口，一个是元素比较的接口，因为这个是优先级的队列。
主要作用：是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，之中的对象只能在其到期时才能从队列中取走。这种队列是有序的，即队头对象的延迟到期时间最长。
```
* <font color=#FF0000>CyclicBarrier和CountDownLatch的区别？</font> 
```
在JDK1.5中，提供CountDownLatch，CyclicBarrier和Semaphore非常有用的辅助类来帮助我们进行并发编程。
CountDownLatch 做减法计算，count=0，唤醒阻塞线程。
CyclicBarrier 做加法计算，count=屏障值（parties），唤醒阻塞线程。
CyclicBarrier 比 CountDownLatch 更灵活，计数达到指定值时，计数置为0重新开始，可重复利用，还有个reset方法可使用。CyclicBarrier照样可以实现CountDownLatch功能
```