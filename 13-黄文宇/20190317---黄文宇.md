2019-03-17
用Java做一个大流量、高并发的网站应该怎么样进行底层构架？采用哪些框架技术比较适合？

Tips : 从框架技术选型。进行相关知识点拓展。举例：负载均衡。好处。坏处。使用场景等方面拓展

一般网站分为，前台和后台（主机服务、缓存服务、数据库、消息队列、微服务、容器化服务等）
前台：网页服务器

对不同的模块采用不同的技术和架构
1、首先描述一下，前端架构思路。主要采用动静分离技术。  
  思路：动静分离是将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。
        动静分离的一种做法是将静态资源部署在nginx上，后台项目部署到应用服务器上，根据一定规则静态资源的请求全部请求nginx服务器，达到动静分离的目标。
        
        1.1 静态资源部署至CDN上
						我们的方案是直接将静态资源全部存放在CDN服务器上。因为之前项目中的JavaScript,CSS以及img文件都是存放在CDN服务器上，将HTML文件一起存放到CDN上之后，可以将静态资源统一
						放置在一种服务器上，便于前端进行维护；而且用户在访问静态资源时，可以很好利用CDN的优点――CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应
						时间等综合信息将用户的请求重新导向离用户最近的服务节点上。

				1.2 后端API提供数据
					后端应用提供API或者微服务，根据前端的请求进行处理，并将处理结果通过JSON格式返回至前端。目前应用主要采用Java平台开发，因此应用服务器主要是Tomcat服务器或者docker容器，
					现在也开始有部分应用采用 node进行开发，应用服务器也开始使用node服务器。

				1.3 前后端域名
					动静分离因为静态资源和应用服务分别部署在不同的服务器上，因此会面临域名策略的选择。
  				1.3.1相同域名
							采用相同域名下，用户请求api时可以避免跨域所带来的问题，相对开发更为快速，工作量也相对小一些。

					1.3.2不同域名
							前后端采用不同域名时，需要前后端开发时兼容跨域请求的情况，开发量相对上一种会稍多一些。解决跨域方式最常用的方式就是采用JSONP，还有一种解决方式使用CORS（HTTP访问控制）
							允许某些域名下的跨域请求。
				2. 动静分离的实现优缺点
					2.1 优点
						2.1.1 api接口服务化：动静分离之后，后端应用更为服务化，只需要通过提供api接口即可，可以为多个功能模块甚至是多个平台的功能使用，可以有效的节省后端人力，更便于功能维护。
            2.1.2 前后端开发并行：前后端只需要关心接口协议即可，各自的开发相互不干扰，并行开发，并行自测，可以有效的提高开发时间，也可以有些的减少联调时间
            2.1.3 减轻后端服务器压力，提高静态资源访问速度：后端不用再将模板渲染为html返回给用户端，且静态服务器可以采用更为专业的技术提高静态资源的访问速度。
          2.2 缺点
           2.2.1  不利于网站SEO（搜索引擎优化）:搜索引擎的网络爬虫一般是根据url访问页面，获取页面的内容后去掉没用的信息例如：CSS，JavaScript，然后分析剩下的文本内容；
               动静分离架构模式前端数据即在是由JavaScript来完成，这就会导致网络爬虫得到的信息部分丢失。在开发中可以采用前端缓存不经常变化数据的方式来解决，只有哪些经常发生变化的数据
               才每次向后端请求。
           2.2.2 开发量变大，前后端交流成本升高：后端api或者微服务返回的数据，往往是有自身逻辑在内的，比如返回数据中的包含status（1-处理中，2-处理成功，3-处理失败），前端需要理解status
             的不同含义，对应的前端操作需要理解（如，status =1 or status = 2，不可提交）。
           2.2.3  在业务高速发展时需要慎重考虑：因为开发量变大，如果在业务开始阶段，缺乏前端又要求开发速度很快，就需要慎重考虑这种方式的实现成本对业务发展的影响。

2、网站数据库，目前大多有MongoDB、MySQL、nosql等数据库技术。我们了解一下，数据库的设计原则
	1）可用性，解决思路是冗余（复制）
		1.1）读可用性：多个从库		
		1.2）写可用性：双主模式 or 双主当主从用
		
 	2）读性能，三种方式扩充读性能
		
		2.1）增加索引：主从上的索引可以不一样		
		2.2）增加从库		
		2.3）增加缓存：服务+缓存+数据一套
		
	3）一致性
		
		3.1）主从不一致：引入中间层 or 读写都走主库		
		3.2）缓存不一致：双淘汰来解决缓存不一致问题
		
	4）扩展性
		
		4.1）数据扩容：提升从库，double主库，秒级扩容		
		4.2）字段扩展：追日志法 or 双写法		
		4.3）水平切分		
				（单key）用户库如何拆分：, user(uid XXOO)	
				（1对多）帖子库如何拆分： tradeid(tid, uid, XXOO)		
				（多对多）好友库如何拆分： friend(uid, friend_uid, XXOO)		
				（多key）订单库如何拆分：order(oid, buyer_id, seller_id, XXOO)
		
	5）SQL编写规则
		
		5.0）不这样编写：联合查询，子查询，触发器，自定义函数，事务		
		5.1）IN查询：分发MR or 拼装成不同SQL语句		
		5.2）非partition key查询：定位一个库 or 分发MR		
		5.3）夸库分页		
			5.3.1）修改sql语句，服务内排序		
			5.3.2）引入特殊id，减少返回数量		
			5.3.3）业务优化，允许模糊查询		
			5.3.4）查询改写，二段查询
		
		说明：
				*** 降低对数据库功能的依赖                                                                                                                                                                                                                      
		        功能应该由程序实现，而非DB实现。原因在于，如果功能由DB实现时，一旦更换的DBMS不如之前的系统强大，不能实现某些功能，这时我们将不得不去修改代码。所以，
		        为了杜绝此类情况的发生，功能应该有程序实现，数据库仅仅负责数据的存储，以达到最低的耦合。
        *** 定义实体关系的原则                                                                                                                                                                                                                          
          当定义一个实体与其他实体之间的关系时，需要考量如下：                                                                                                                                                                                        
          牵涉到的实体 识别出关系所涉及的所有实体。                                                                                                                                                                                                   
          所有权 考虑一个实体“拥有”另一个实体的情况。                                                                                                                                                                                               
          基数 考量一个实体的实例和另一个实体实例关联的数量。     
          
1、在后端可以采用API（一般采用spring restful开发）提供给前端访问的接口。
 
   优点：                                                                                                                                                     	                                                                                                                                                                                                                                                                                                                                                         
   1）.适合开放性高的API。这几年的由于移动互联网流行使得前端设备多样化，业界急需一种统一的机制来规范API设计，使得API适用于各种各样的前端设备，REST符合这种需求。                                                                                                                                                           
   2）.行为和资源分离，更容易理解。                                                                                                                                                                                                                                                                                        
   3）.提出使用版本号（例如v1、v2），更加规范   
   缺点：
   1）.对后端开发人员要求高，业务逻辑有时难以被抽象为资源的增删改查。                                                                                                                                                                                                                                                                        
   2）.对前端开发人员不友好，API粒度较粗，难以查询符合特殊要求的数据，同样的业务要比普通的API需要更多次HTTP请求。
   
2、现在流行微服务基于spring cloud或者RPC开发
   2.1 设计要素
		*Version 
		*RequstID 
		*Auth&Signature 
		*RateLimit 
		*Docs 
		*ErrorCode&Message
	
	2.2 服务框架
			2.2。1 服务注册、发现、负载均衡和健康检查，假定采用进程内LB方案，那么服务自注册一般统一做在服务器端框架中，健康检查逻辑由具体业务服务定制，框架层提供调用健康检查逻辑的机制，
					服务发现和负载均衡则集成在服务客户端框架中。
			2.2.2	监控日志，框架一方面要记录重要的框架层日志、metrics和调用链数据，还要将日志、metrics等接口暴露出来，让业务层能根据需要记录业务日志数据。在运行环境中，所有日志数据一般
					集中落地到企业后台日志系统，做进一步分析和处理。
			2.2.3 REST/RPC和序列化，框架层要支持将业务逻辑以HTTP/REST或者RPC方式暴露出来，HTTP/REST是当前主流API暴露方式，在性能要求高的场合则可采用Binary/RPC方式。针对当前多样化的设
						备类型(浏览器、普通PC、无线设备等)，框架层要支持可定制的序列化机制，例如，对浏览器，框架支持输出Ajax友好的JSON消息格式，而对无线设备上的Native App，框架支持输出性能高的Binary
					消息格式。
			2.2.4 配置，除了支持普通配置文件方式的配置，框架层还可集成动态运行时配置，能够在运行时针对不同环境动态调整服务的参数和配置。
			2.2.5 限流和容错，框架集成限流容错组件，能够在运行时自动限流和容错，保护服务，如果进一步和动态配置相结合，还可以实现动态限流和熔断。
			2.2.6 管理接口，框架集成管理接口，一方面可以在线查看框架和服务内部状态，同时还可以动态调整内部状态，对调试、监控和管理能提供快速反馈。Spring Boot微框架的Actuator模块就是一个强大
						的管理接口。
			2.2.7 统一错误处理，对于框架层和服务的内部异常，如果框架层能够统一处理并记录日志，对服务监控和快速问题定位有很大帮助。
			2.2.8 安全，安全和访问控制逻辑可以在框架层统一进行封装，可做成插件形式，具体业务服务根据需要加载相关安全插件。
			2.2.9 文档自动生成，文档的书写和同步一直是一个痛点，框架层如果能支持文档的自动生成和同步，会给使用API的开发和测试人员带来极大便利。Swagger是一种流行Restful API的文档方案。
	2.3 微服务需要包括的功能
		日志和审计，主要是日志的汇总，分类和查询
		监控和告警，主要是监控每个服务的状态，必要时产生告警
		消息总线，轻量级的MQ或HTTP
		注册发现
		负载均衡
		部署和升级
		事件调度机制
		资源管理，如：底层的虚拟机，物理机和网络管理
		认证和鉴权
		微服务统一代码框架，支持多种编程语言
		统一服务构建和打包
		统一服务测试
		微服务CI/CD流水线
		服务依赖关系管理
		统一问题跟踪调试框架，俗称调用链
		灰度发布
		蓝绿部署
		
  2.4微服务和docker容器
  	* 容器够小 
				C解决微服务对机器数量的诉求 
		*容器独立 
				C解决多语言问题 
		*开发环境与生产环境相同 
				C单机开发、提升效率 
		*容器效率高 
				C省钱 
		*代码/image一体化 
				C可复用管理系统 
		*容器的横向与纵向扩容 
				C可复制 
				C可动态调节CPU与内存		
		*Image管理 
		*系统安全管理 
		*授权管理 
		*系统成熟度 
		*社区成熟度

	  		
 2.4 优缺点  
	优点：
				*每个微服务都很小，这样能聚焦一个指定的业务功能或业务需求。                                              
        *微服务能够被小团队单独开发，这个小团队是2到5人的开发人员组成。                                          
        *微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的。                            
        *微服务能使用不同的语言开发。                                                                            
        *微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如Jenkins, bamboo 。                          
        *一个团队的新成员能够更快投入生产。                                                                      
        *微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。
        *微服务允许你利用融合最新技术。                                                                          
        *微服务只是业务逻辑的代码，不会和HTML,CSS 或其他界面组件混合。                                           
        *微服务能够即时被要求扩展。                                                                              
        *微服务能部署中低端配置的服务器上。                                                                      
        *易于和第三方集成。                                                                                      
        *每个微服务都有自己的存储能力，可以有自己的数据库。也可以有统一数据库。  
  缺点：
       	*微服务架构可能带来过多的操作。
				*需要DevOps技巧 ，可能双倍的努力。
				*分布式系统可能复杂难以管理。
				*因为分布部署跟踪问题难。
				*当服务数量增加，管理复杂性增加。
	
	2.5、服务治理相关			
	微服务治理
		*按需伸缩 
			C部署与监控运维成本 
		*独立部署 
			C机器数量与部署成本 
		*业务独立 
			C服务依赖、治理，版本管理、事务处理 
		*技术多样性 
		C环境部署成本、约定成本

	运行状态治理 
		C监控、限流、SLA、LB、日志分析 		
	服务注册与发现 
	部署 
		C快速、复制、扩容 
		C单机开发 		
  调用 
		C安全、容错、服务降级、调用延时			    
	
	
	2.6 另说明，需要考虑的问题
			** 单个微服务代码量小，易修改和维护。但是，系统复杂度的总量是不变的，每个服务代码少了，但服务的个数肯定就多了。就跟拼图游戏一样，切的越碎，越难拼出整幅图。一个系统被拆分成零碎
						的微服务，最后要集成为一个完整的系统，其复杂度肯定比大块的功能集成要高很多。
			** 单个微服务数据独立，可独立部署和运行。虽然微服务本身是可以独立部署和运行的，但仍然避免不了业务上的你来我往，这就涉及到要对外通信，当微服务的数量达到一定量级的时候，如何提供
						一个高效的集群通信机制成为一个问题。
			** 单个微服务拥有自己的进程，进程本身就可以动态的启停，为无缝升级的打好了基础，但谁来启动和停止进程，什么时机，选择在哪台设备上做这件事情才是无缝升级的关键。这个能力并不是微服
						务本身提供的，而是需要背后强大的版本管理和部署能力。
			** 多个相同的微服务可以做负载均衡，提高性能和可靠性。正是因为相同微服务可以有多个不同实例，让服务按需动态伸缩成为可能，在高峰期可以启动更多的相同的微服务实例为更多用户服务，以
					此提高响应速度。同时这种机制也提供了高可靠性，在某个微服务故障后，其他相同的微服务可以接替其工作，对外表现为某个设备故障后业务不中断。同样的道理，微服务本身是不会去关心系统
					负载的，那么什么时候应该启动更多的微服务，多个微服务的流量应该如何调度和分发，这背后也有一套复杂的负载监控和均衡的系统在起作用。
			** 微服务可以独立部署和对外提供服务，微服务的业务上线和下线是动态的，当一个新的微服务上线时，用户是如何访问到这种新的服务？这就需要有一个统一的入口，新的服务可以动态的注册到这个
					入口上，用户每次访问时可以从这个入口拿到系统所有服务的访问地址。这个统一的系统入口并不是微服务本身的一部分，所以这种能力需要系统单独提供。
			** 还有一些企业级关注的系统问题，比如，安全策略如何集中管理？系统故障如何快速审计和跟踪到具体服务？整个系统状态如何监控？服务之间的依赖关系如何管理？等等这些问题都不是单个微服务
				考虑的范畴，而需要有一个系统性的考虑和设计，让每个微服务都能够按照系统性的要求和约束提供对应的安全性，可靠性，可维护性的能力。
				
2.7 主机服务
		2.7.1 负载均衡系统
			负载均衡系统分为硬件和软件两种。
			硬件负载均衡效率高，但是价格贵，比如F5等。
			软件负载均衡系统价格较低或者免费，效率较硬件负载均衡系统低，不过对于流量一般或稍大些网站来讲也足够使用，比如lvs。

		2.7.2 反向代理系统
			目前普遍使用Squid或者nginx,或者Lighttpd，Varish。
			这四者又各自有很大的差异。
			Squid：主要用来做反向代理，使用内存+硬盘
			Nginx：可以反向代理+负载均衡+WWW解析
			Lighttpd：反向代理能力一般，处理FastCGI比较好，消耗内存很小
			Varish：主要做内存的反向代理，性能最优

		2.7.3 Web服务器系统
			由Apache负责解析PHP内容，也可以用Nginx，或者Lighttpd，相对来说Apache比较稳定。

		2.7.4 分布式存储系统
				存储量很大，经常会达到单台服务器无法提供的规模，比如相册、视频等应用。因此需要专业的大规模存储系统。

		2.7.5 底层服务系统
				根据各自需要由服务调用。

		2.7.6 数据库系统
			**使用MySQL数据库，考虑到Web应用的数据库读多写少的特点，我们主要对读数据库做了优化，提供专用的读数据库和写数据库，在应用程序中实现读操作和写操作分别访问不同的数据库。
			**使用同步机制实现快速将主库(写库)的数据库复制到从库(读库)。一个主库对应多个从库，主库数据实时同步到从库。
			**写数据库有多台，每台都可以提供多个应用共同使用，这样可以解决写库的性能瓶颈问题和单点故障问题。				

2.8 缓存服务
  一般缓存可以使用ngix、Redis、ehcache、mecache等相关技术
  具体描述一下Redis
  
  2.8.1 持久化机制：将redis内存中的数据持久化到磁盘中，然后可以定期将磁盘文件上传至S3(AWS)或者ODPS（阿里云）等一些云存储服务上去。
    2.8.1.1 RDB 
					对redis中的数据执行周期性的持久化，每一刻持久化的都是全量数据的一个快照。对redis性能影响较小，基于RDB能够快速异常恢复
		2.8.1.2 AOF 
							以append-only的模式写入一个日志文件中，在redis重启的时候可以通过回放AOF日志中的写入指令来重新构建整个数据集。（实际上每次写的日志数据会先到linux os cache，然后redis每隔一秒
					调用操作系统fsync将os cache中的数据写入磁盘）。对redis有一定的性能影响，能够尽量保证数据的完整性。redis通过rewrite机制来保障AOF文件不会太庞大，基于当前内存数据并可以做适当的
					指令重构。
							如果同时使用RDB和AOF两种持久化机制，那么在redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整，建议将两种持久化机制都开启，用AOF来保证数据不丢失，作为数据恢
					复的第一选择；用RDB来作不同程度的冷备，在AOF文件都丢失或损坏不可用的时候来快速进行数据的恢复。

							实战踩坑：对于想从RDB恢复数据，同时AOF开关也是打开的，一直无法正常恢复，因为每次都会优先从AOF获取数据（如果临时关闭AOF，就可以正常恢复）。此时首先停止redis，然后关闭AOF，
							拷贝RDB到相应目录，启动redis之后热修改配置参数redis config set appendonly yes，此时会自动生成一个当前内存数据的AOF文件，然后再次停止redis，打开AOF配置，再次启动数据就正常启动
	2.8.2 redis集群
			replication 
							一主多从架构，主节点负责写，并且将数据同步到其他salve节点（异步执行），从节点负责读，主要就是用来做读写分离的横向扩容架构。这种架构的master节点数据一定要做持久化，否则，
					当master宕机重启之后内存数据清空，那么就会将空数据复制到slave，导致所有数据消失
			sentinal哨兵 
							哨兵是redis集群架构中很重要的一个组件，负责监控redis master和slave进程是否正常工作，当某个redis实例故障时，能够发送消息报警通知给管理员，当master node宕机能够自动转移
					到slave node上，如果故障转移发生来，会通知client客户端新的master地址。sentinal至少需要3个实例来保证自己的健壮性，并且能够更好地进行quorum投票以达到majority来执行故障转移。 
							前两种架构方式最大的特点是，每个节点的数据是相同的，无法存取海量的数据。因此哨兵集群的方式使用与数据量不大的情况
			redis cluster 
						redis cluster支撑多master node，每个master node可以挂载多个slave node，如果mastre挂掉会自动将对应的某个slave切换成master。需要注意的是redis cluster架构下slave节点主要是用
				来做高可用、故障主备切换的，如果一定需要slave能够提供读的能力，修改配置也可以实现（同时也需要修改jedis源码来支持该情况下的读写分离操作）。redis cluster架构下，master就是可
				以任意扩展的，直接横向扩展master即可提高读写吞吐量。slave节点能够自动迁移（让master节点尽量平均拥有slave节点），对整个架构过载冗余的slave就可以保障系统更高的可用性。
				
2.9 消息服务，一般使用kafka
     	2.9.1同时为发布和订阅提供高吞吐量。Kafka每秒可以生产约25万消息（约50 MB），每秒处理55万消息（约110 MB）。
     	2.9.2 可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。
			2.9.3分布式系统，易于向外扩展。所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。
			2.9.4消息被处理的状态是在consumer端维护，而不是由server端维护。当失败时能自动平衡。
