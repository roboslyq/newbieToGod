线程类的构造方法、静态块是被哪个线程调用的?

静态块是被新建的线程调用
线程类的构造方法是被线程自己调用

同步方法和同步块，哪个是更好的选择?

同步方法比同步方法块的范围大，系统会有一定的延迟。对方法块加锁，延迟会小点

如何检测死锁？怎么预防死锁？
一般在Linux系统中使用top命令查看系统进程调用，
1、一般大量的系统调用
2、不可剥夺的进程在抢占CPU资源，使得其他进程服务到CPU资源
3、系统频繁调用导致很多事件放在队列中，得不到系统调用


预防死锁：
1、按照进程的顺序进行加锁
2、对锁设置时间限制，如果超时就释放锁



2019-03-15

1、线程池作用，主要实现类，并说出实现类场景以及区别
多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力
 一个线程池包括以下四个基本组成部分：
    1、线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；
    2、工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
  	3、任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
 		4、任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。
 		java.util.concurrent目录下的接口
 		 1、Executor
 		   void execute(Runnable command);
 		    它包含了一个方法execute，参数为一个Runnable接口引用。
        Executor接口将任务的提交与执行分离开来。
 		 2、ExecutorService
 		   void shutdown();
 		   boolean isShutdown();
 		   boolean isTerminated();
			 boolean awaitTermination(long timeout, TimeUnit unit)
        throws InterruptedException；
        
      <T> T invokeAny(Collection<? extends Callable<T>> tasks,
                    long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
    3、Executors对ExecutorService接口的方法进行扩展    
        newFixedThreadPool、newWorkStealingPool等
    4、ThreadPoolExecutor类(java.util.concurrent.ThreadPoolExecutor)
        它是线程池的核心实现类，用来执行被提交的任务
				它通常由工厂类Executors来创建，Executors可以创建SingleThreadExecutor，FixedThreadPool以及CachedThreadPool等不同的ThreadPoolExecutor。    

		Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；
　　然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；
　　抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；
　　然后ThreadPoolExecutor继承了类AbstractExecutorService。

2、ThreadPoolExecutor使用场景。以及原理
线程池最核心的类是ThreadPoolExecutor，是有四个以下四个组件组成
・corePool：核心线程池的大小。
・maximumPool：最大线程池的大小。
・BlockingQueue：用来暂时保存任务的工作队列。
・RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时（达到了最大线程池大小且工作队列已满），execute()方法将要调用的Handler。

通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor。
    ・FixedThreadPool  可重用固定线程数的线程池。    
        ThreadPoolExecutor(nThreads,nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue())
        1）如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。
        2）在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。
        3）线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。
  
    ・SingleThreadExecutor  使用单个worker线程的Executor
    		public  static  ExecutorService?newSingleThreadExecutor(){
    			return  new  FinalizableDelegatedExecutorService(new  ThreadPoolExecutor(1,1,0L, TimeUnit.MILLISECONDS,new  LinkedBlockingQueue()));}
						SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）
    
    ・CachedThreadPool   一个会根据需要创建新线程的线程池
      public static ExecutorService  newCachedThreadPool() {  return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,new SynchronousQueue());}
		极端情况下， CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源
		
3、Executor拒绝策略说的是什么？
当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：
1)、ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
     ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 10, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5));
                
     ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 10, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5), new ThreadPoolExecutor.AbortPolicy());


2)、ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
      ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 10, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5), new ThreadPoolExecutor.DiscardPolicy());
    
   
3)、ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
			ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 10, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5), new ThreadPoolExecutor.DiscardOldestPolicy());
                
                
4)、ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
    ThreadPoolExecutor executor = new ThreadPoolExecutor(10 ,20, 10, TimeUnit.MILLISECONDS,
                new ArrayBlockingQueue<Runnable>(5), new ThreadPoolExecutor.CallerRunsPolicy());


4、无界阻塞延迟队列delayqueue原理是什么？
 * @since 1.5
 * @author Doug Lea
 * @param <E> the type of elements held in this collection
 */
public class DelayQueue<E extends Delayed> extends AbstractQueue<E>
    implements BlockingQueue<E> {
    
    DelayQueue中内部使用的是PriorityQueue存放数据，使用ReentrantLock实现线程同步，可知是阻塞队列。
    另外队列里面的元素要实现Delayed接口，一个是获取当前剩余时间的接口，一个是元素比较的接口，因为这个是有优先级的队列。
    
    PriorityQueue中的默认值是11（ @since 1.5）
    1）、offer操作
    public boolean offer(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            q.offer(e);
            if (q.peek() == e) {
                leader = null;
                available.signal();
            }
            return true;
        } finally {
            lock.unlock();
        }
    }
    获取独占锁，然后添加元素到优先级队列，由于q是优先级队列，所以添加元素后，peek并不一定是当前添加的元素，
    如果（2）为true，说明当前元素e的优先级最小也就即将过期的，这时候激活avaliable变量条件队列里面的线程，通知他们队列里面有元素了。
    2）、 poll操作
     public E poll() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            E first = q.peek();
            if (first == null || first.getDelay(NANOSECONDS) > 0)
                return null;
            else
                return q.poll();
        } finally {
            lock.unlock();
        }
    }
        获取并移除队头过期元素，否者返回null
  3）、take操作
     public E take() throws InterruptedException {
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            for (;;) {
            （1）
                E first = q.peek();
                if (first == null) 
                    available.await();（2）
                else {
                    long delay = first.getDelay(NANOSECONDS);
                    if (delay <= 0)（3）
                        return q.poll();
                    first = null; // don't retain ref while waiting
                    if (leader != null)（4）
                        available.await();
                    else {
                        Thread thisThread = Thread.currentThread();
                        leader = thisThread;（5）
                        try {
                            available.awaitNanos(delay);
                        } finally {
                            if (leader == thisThread)
                                leader = null;
                        }
                    }
                }
            }
        } finally {
            if (leader == null && q.peek() != null)（6）
                available.signal();
            lock.unlock();
        }
    }
    
    获取并移除队列首元素，如果队列没有过期元素则等待。
    第一次调用take时候由于队列空，所以调用（2）把当前线程放入available的条件队列等待，当执行offer并且添加的元素就是队首元素时候就会通知最先等待的线程激活，循环重新获取队首元素，
    这时候first假如不空，则调用getdelay方法看该元素海剩下多少时间就过期了，如果delay<=0则说明已经过期，则直接出队返回。否者看leader是否为null，
    不为null则说明是其他线程也在执行take则把该线程放入条件队列，否者是当前线程执行的take方法，则调用(5)await直到剩余过期时间到（这期间该线程会释放锁，
    所以其他线程可以offer添加元素，也可以take阻塞自己），剩余过期时间到后，该线程会重新竞争得到锁，重新进入循环。
		（6）说明当前take返回了元素，如果当前队列还有元素则调用singal激活条件队列里面可能有的等待线程。leader那么为null，
			那么是第一次调用take获取过期元素的线程，第一次调用的线程调用设置等待时间的await方法等待数据过期，后面调用take的线程则调用await直到signal。
			
 总结：       重试机制实现，比如当调用接口失败后，把当前调用信息放入delay=10s的元素，然后把元素放入队列，那么这个队列就是一个重试队列，
            一个线程通过take方法获取需要重试的接口，take返回则接口进行重试，失败则再次放入队列，同时也可以在元素加上重试次数。
            
            ScheduledThreadPoolExecutor中DelayedWorkQueue是对其的优化使用


5、CyclicBarrier和CountDownLatch的区别？
	CountDownLatch和CyclicBarrier是jdk concurrent包下非常有用的两个并发工具类，它们提供了一种控制并发流程的手段

  CyclicBarrier
  让一组线程到达一个同步点后再一起继续运行，在其中任意一个线程未达到同步点，其他到达的线程均会被阻塞。
  CyclicBarrier提供两个构造方法
  
   CyclicBarrier(int parties)
   默认构造方法，参数表示拦截的线程数量。
   
   CyclicBarrier(int parties, Runnable barrierAction)：
   由于线程之前的调度是由CPU决定的，所以默认的构造方法无法设置线程执行优先级，
   CyclicBarrier提供一个更高级的构造函数CyclicBarrier(int parties, Runnable barrierAction)，用于在线程到达同步点时，
   优先执行线程barrierAction，这样可以更加方便的处理一些负责的业务场景
   
   创建CyclicBarrier后，每个线程调用await方法告诉CyclicBarrier自己已经到达同步点，然后当前线程被阻塞
		dowait实现
		1）、在dowait的前段部分，主要完成了当所有线程都到达同步点（barrier）时，唤醒所有的等待线程，一起往下继续运行，可根据参数barrierAction决定优先执行的线程。
		2）、在dowait的实现后半部分，主要实现了线程未到达同步点（barrier）时，线程进入Condition自旋等待，直到等待超时或者所有线程都到达barrier时被唤醒。
		3）、    使用ReentrantLock保证每一次操作线程安全；
           线程等待/唤醒使用Lock配合Condition来实现；
          线程被唤醒的条件：等待超时或者所有线程都到达barrier。
		


		CountDownLatch
		CountDownLatch允许一个或多个线程等待其他线程完成操作。
		    public void countDown() {
        sync.releaseShared(1);
    }
				CountDownLatch的构造函数接受int型参数作为它的计数器，如果想等待N个点完成，就传入N；
    
    
    
			  public boolean await(long timeout, TimeUnit unit)
        throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    		}
    		
		调用CountDownLatch的countDown方法时，N会减1，CountDownLatch的await方法会阻塞主线程直到N减少到0
		同步器Sync实现了共享式获取同步状态的acquire和release
		从构造方法的具体实现可以看出，通过构造方法传入的int型参数count其实就是同步器的状态。
		
		  public CountDownLatch(int count) {
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
    }
		CountDownLatch提供带超时时间的await和不带超时时间的await
		await的实质是在获取同步状态，同步状态state == 0成立，当前等待完成的点均已完成，主线程继续往下执行，否则，
		主线程进入等待队列自旋等待直到同步状态释放后state == 0。有些时候主线程是不能一直自旋等待，这个时候带超时时间的await就派上用场了，设
		置超时时间，如果在指定时间内N个点都未完成，返回false，主线程不再等待，继续往下执行。
		
		说明：CountDownLatch实质上就是一个AQS计数器，通过AQS来实现线程的等待与唤醒。

		CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；
		CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。

		对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，
		重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。
		
		CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。



