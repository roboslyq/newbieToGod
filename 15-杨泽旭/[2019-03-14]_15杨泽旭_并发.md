# Java刷题小分队-0314
## 线程类的构造方法、静态块是被哪个线程调用的?
线程类的构造方法、静态块，是被new这个线程的类所在的线程调用的，run方法里面的代码才是被线程类所调用的。

## 同步方法和同步块，哪个是更好的选择?
同步方法默认使用this或者当前类做为锁。
同步代码块可以选择以什么来加锁，比同步方法更精确，我们可以选择只有会在同步发生同步问题的代码加锁，而并不是整个方法。
一般来说同步代码块会比同步方法好。
## 如何检测死锁？怎么预防死锁？
### 检测死锁
可以用Jstack工具或者JConsole工具检测死锁。
### 预防死锁
死锁产生条件：
只有以下这四个条件都发生时才会出现死锁：
1. 互斥，共享资源 X 和 Y 只能被一个线程占用；
2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。
**只要破坏其中一个就可以避免死锁发生**。
1. 对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。增加一个资源管理员类，只有需要的所有资源都可获取，才能同时申请所有资源。处理完同时释放。
2. 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。可以用java.util.concurrent 包下面提供的 Lock。
3. 对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。