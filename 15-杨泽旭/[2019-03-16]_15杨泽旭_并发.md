# Java刷题小分队-0316 15-杨泽旭
## 1、Java中的同步集合与并发集合有什么区别？
同步集合和并发集合都是支持线程安全的，区别是性能和可获展性，以及实现线程安全的方法不一样。
同步集合类,像是HashTable，就是把put、get、size等方法加上了synchronized。所有并发操作都竞争同一把锁，一个线程操作时，其他线程只能等待。
Collections提供的同步包装也只是利用输入 Map 构造了另一个同步版本，所有操作虽然不再声明成为 synchronized 方法，但是还是利用了“this”作为互斥的 mutex，没有真正意义上的改进。
``` java
private static class SynchronizedMap<K,V>
    implements Map<K,V>, Serializable {
    private final Map<K,V> m;     // Backing Map
    final Object      mutex;        // Object on which to synchronize
    // …
    public int size() {
        synchronized (mutex) {return m.size();}
    }
 // … 
}
```
**所以同步集合类或者同步包装版本，都只是适合在非高强度并发的场景下**。
并发集合类：ConcurrentHashMap
早期 ConcurrentHashMap，其实现是基于：
* 分离锁，也就是将内部进行分段（Segment），里面则是 HashEntry 的数组，和 HashMap 类似，哈希相同的条目也是以链表形式存放。
* HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的
ConcurrentHashMap、CopyOnWriteArrayList、 CopyOnWriteHashSet
1.8版本初同步的粒度更细致；始化采用lazy-load形式，避免了初始化开销；使用CAS等操作，在特定场景进行无锁并发操作等。
所以并发集合比同步集合更加精细化，支持并发强度更高。
## 2、Java中invokeAndWait 和 invokeLater有什么区别？
Sorry，我没有用过swing，这两个方法也没有接触过，摘抄一段网上的答案：
> invokeLater,invokeAndWait是专门给Swing的线程安全准备的两个方法，Swing是线程不安全的，是单线程的设计，复杂的Swing交互一定要考虑多线程的问题。   
> 因此只能从事件派发线程访问将要在屏幕上绘制的Swing组件。事件派发线程是调用paint和update等回调方法的线程，它还是事件监听器接口中定义的事件处理方法，例如，ActionListener中的   
> actionPerformed方法在事件派发线程中调用。  
> Swing是事件驱动的，所以在回调函数中更新可见的GUI是很自然的事情，比如，有一个按钮被按下，项目列表需要更新时，则通常在与该按钮相关联的事件监听器的actionPerformed方法中来实现该列表的更新，从事件派发线程以外的线程中更新Swing组件是不正常的。  
> ---------------------   
> invokeLater和invoikeAndWait的一个重要区别：**可以从事件派发线程中调用invokeLater，却不能从事件派发线程中调用   
> invokeAndWait**，从事件派发线程调用invokeAndWait的问题是：invokeAndWait锁定调用它的线程，直到可运行对象从事件派发线程中派发出去并且该可运行的对象的run方法激活，如果从事件派发线程调用invoikeAndWait，则会发生死锁的状况，因为   
> invokeAndWait正在等待事件派发，但是，由于是从事件派发线程中调用invokeAndWait，所以直到invokeAndWait返回后事件才能派发。   
> 例如：actionPerformed();返回的时候事件派发线程才能派发线程，而在actionPerformed中使用invokeAndWait则会导致actionPerformed不能返回。所以也就无法派发invokeAndWait中的线程。  
> ---------------------   
> 作者：_cuiyaoqiang   
> 来源：CSDN   
> 原文：https://blog.csdn.net/cuiyaoqiang/article/details/51319840   
## 3、什么是FutureTask？
![1025005-20161030180319421-1644150953](https://ws4.sinaimg.cn/large/006tKfTcly1g151xnh3rxj30ds0f474m.jpg)
**Runnable**封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法。**Callable**与Runnable类似，但是有返回值。Callable接口是一个参数化的类型，只有一个方法call。
**Future**保存异步计算的结果。可以启动一个计算，将Future对象交给某个线程，然后忘掉它。Future对象的所有者在结果计算好之后就可以获得它。

``` java
Runnable task = () -> {System.*out*.println("Hello World!");};
Future future = (Future) Executors.*newFixedThreadPool*(1)
        .submit(task)
        .get();
```
Future接口具有下面的方法：
``` java
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;
}
```
第一个get方法的调用被阻塞，直到计算完成。如果在计算完成之前，第二个get方法的调用超时，抛出一个TimeoutException异常。如果运行该计算的线程被中断，两个方法都将抛出InterruptedException。如果计算已经完成，那么get方法立即返回。
如果计算还在进行，isDone方法返回false；如果完成了，则返回true。
可以用cancel方法取消该计算。如果计算还没有开始，它被取消且不再开始。如果计算处于运行之中，那么如果mayInterrupt参数为true，它就被中断。
**FutureTask**是Future的实现类，如上面类继承关系，它还继承了Runnable；所以FutureTask即可以作为Runnable被Thread执行，也可以作为Future获取Callable的结果。
> 深入学习可以参考这篇文章  
> [深入学习 FutureTask - ImportNew](http://www.importnew.com/25286.html)  
